# floating point

## 부동소수점 오차란?

```python
>>> print(.1 + .2)
0.30000000000000004
>>> 0.1 * 3 == 0.3
False
>>> 1.2 - 0.1 == 1.1
False
```

위와 같은 현상은 부동소수점 때문에 발생하는 문제이다.



## 부동소수점의 표현 방식

컴퓨터에서 부동소수점은 2진 분수로 표현되기에 꽤 많은 값은 정확히 표현될 수 없다. 그렇기에 사람이 사용하는 10진 부동소수점 숫자는 2진 부동소수점 숫자로 근사된다. 예를 들어 10진수 0.1은 2진 분수로 정확하게 표현될 수 없고 `0.0001100110011001100110...`처럼 무한히 반복되기에 특정 비트에서 멈추고 근사값을 얻는다. 이런 부동소수점의 한계는 파이썬뿐만 아니라 부동소수점을 지원하는 거의 모든 언어에서 찾아볼 수 있다.



## Python에서의 해결책

#### `decimal.Decimal()`

```python
>>> import decimal
>>> decimal.Decimal('0.1') * 3 == decimal.Decimal('0.3')
True
>>> decimal.Decimal('0.3') + 2
Decimal('2.3')
```

`decimal` 모듈을 사용하면 위 문제를 가장 깔끔하게 해결할 수 있다. Python 문서에서도 언급하듯 빠르고 정확한 부동 소수 산술을 지원하며 `float` 자료형을 그대로 사용할 때 보다 여러 이점이 있다고 말한다.

#### `math.fsum()`

```python
>>> sum([.1] * 10)
0.9999999999999999
>>> math.fsum([.1] * 10)
1.0
```

두 개 이상의 부동소수점 합계와 관련된 반올림 오류 누적을 제거하여 정밀도 손실을 방지할 수 있다.

다만 `fsum()`은 중간중간 누적된 오류를 해결하기 위함이지 정확한 부동소수점 연산을 위한 게 아니다 보니 유명한 `0.1 + 0.2`처럼 항상 원하는 결과를 기대할 수는 없다.

```python
>>> math.fsum([.1, .2])
0.30000000000000004
```

#### `round()`

```python
>>> round(0.1 + 0.1 + 0.1, 10) == round(0.3, 10)
True
>>> round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)
False
```

빌트인 함수로 있는 `round()`로 반올림해 해결하는 방법도 있다. 다만 각각 반올림하고 더해주면 결과가 다르게 나올 것이다.

#### `math.is_close()`

`isclose(a, b, rel_tol=1e-9, abs_tol=0.0)`같은 형태이며 `a`와 `b`는 비교할 값들, `rel_tol`은 relative tolerance, `abs_tol`은 absolute tolerance다. `decimal`을 사용할 만큼 엄격한 상황이 아니라면 위에 나온 방법들보다 제일 간단하고 직관적이다.



## References

https://blog.winterjung.dev/2020/01/06/floating-point-in-python (파이썬에서 부동소수점 오차 해결하기)

https://0.30000000000000004.com/ (Floating Point Math)